[
  {
    "path": "rust-racingcar/src/main.rs",
    "code": [
      "#[path = \"view/input.rs\"] mod input;\n",
      "#[path = \"model/game.rs\"] mod game;\n",
      "#[path = \"test/test.rs\"] mod test;\n",
      "#[path = \"test/game-test.rs\"] mod game_test;\n",
      "use crate::game::GameFn;\n",
      "\n",
      "fn main() {\n",
      "    println!(\"Rust\ub85c \uad6c\ud604\ud558\ub294 \uc790\ub3d9\ucc28 \uacbd\uc8fc \uac8c\uc784\");\n",
      "\n",
      "    // \uc790\ub3d9\ucc28 \ub300\uc218\ub97c \uc785\ub825\ubc1b\ub294\ub2e4.\n",
      "    println!(\"\uc790\ub3d9\ucc28 \ub300\uc218\ub294 \uba87 \ub300\uc778\uac00\uc694?\");\n",
      "    let the_number_of_cars: i32 = input::input_integer();\n",
      "    println!(\"\uc785\ub825\ubc1b\uc740 \uc790\ub3d9\ucc28 \ub300\uc218: {:?}\", the_number_of_cars);\n",
      "\n",
      "    // \uc2dc\ub3c4\ud560 \ud69f\uc218\ub97c \uc785\ub825\ubc1b\ub294\ub2e4.\n",
      "    println!(\"\uc2dc\ub3c4\ud560 \ud69f\uc218\ub294 \uba87 \ud68c\uc778\uac00\uc694?\");\n",
      "    let the_number_of_attempts: i32 = input::input_integer();\n",
      "    println!(\"\uc2dc\ub3c4\ud560 \ud69f\uc218: {:?}\", the_number_of_attempts);\n",
      "\n",
      "    println!(\"\uacbd\uc8fc\ud560 \uc790\ub3d9\ucc28 \uc774\ub984\uc744 \uc785\ub825\ud558\uc138\uc694(\uc774\ub984\uc740 \uc27c\ud45c(,)\ub97c \uae30\uc900\uc73c\ub85c \uad6c\ubd84).\");\n",
      "    let player_names: Vec<String> = input::input_names();\n",
      "    println!(\"\uc785\ub825 \ubc1b\uc740 \uc790\ub3d9\ucc28 \uc774\ub984, {:?}\", player_names);\n",
      "\n",
      "    <game::Game as GameFn>::new(player_names, the_number_of_cars, the_number_of_attempts);\n",
      "}\n"
    ],
    "startline": 1,
    "endline": 25
  },
  {
    "path": "rust-racingcar/src/test/game-test.rs",
    "code": [
      "#[path = \"../model/game.rs\"] mod game;\n",
      "\n",
      "use std::panic;\n",
      "use game::player;\n",
      "use crate::game::{Game as TestGame, Game};\n",
      "use crate::game_test;\n",
      "use crate::game::{GameFn, MockGameFn};\n",
      "use crate::game::player::step;\n",
      "\n",
      "fn run_test<T>(test: T)\n",
      "    where T: FnOnce(&TestGame) -> () + panic::UnwindSafe\n",
      "{\n",
      "    let name_of_players = vec![\"pobi\".to_string(), \"crong\".to_string(), \"honux\".to_string()];\n",
      "    let number_of_players = 3;\n",
      "    let number_of_attempts = 5;\n",
      "\n",
      "    // https://medium.com/@ericdreichert/test-setup-and-teardown-in-rust-without-a-framework-ba32d97aa5ab\n",
      "    let test_game_create_result = panic::catch_unwind(|| {\n",
      "        TestGame::new(name_of_players, number_of_players, number_of_attempts)\n",
      "    }).map(|test_game| {\n",
      "        test(&test_game)\n",
      "    });\n",
      "\n",
      "    match test_game_create_result {\n",
      "        Ok(_) => {\n",
      "            println!(\"test_game_create_result passed\");\n",
      "        }\n",
      "        Err(_) => {\n",
      "            panic!(\"Test game creation failed\");\n",
      "        }\n",
      "    }\n",
      "}\n",
      "\n",
      "#[test]\n",
      "fn is_able_to_create_new_game_struct() {\n",
      "    run_test(|new_game| {\n",
      "        assert_eq!(new_game.get_number_of_players(), 3);\n",
      "        assert_eq!(new_game.get_number_of_attempts(), 5);\n",
      "    });\n",
      "}\n",
      "\n",
      "#[test]\n",
      "fn is_able_to_create_new_step_struct_in_player() {\n",
      "    run_test(|new_game| {\n",
      "        // given\n",
      "        let original_players = new_game.get_players();\n",
      "        // clone players\n",
      "        let mut players = Vec::with_capacity(original_players.len());\n",
      "        players.clone_from(original_players);\n",
      "        let player = players.get_mut(0).unwrap();\n",
      "\n",
      "        // when\n",
      "        let steps = player.get_steps();\n",
      "\n",
      "        // then\n",
      "        assert_eq!(steps.len(), new_game.get_number_of_attempts() as usize);\n",
      "\n",
      "        let step = steps.get(0).unwrap();\n",
      "        assert_eq!(step.get_step_number(), 1);\n",
      "    });\n",
      "}\n",
      "\n",
      "#[test]\n",
      "fn test_mocked_game_new_function() {\n",
      "    let step_case_1 = step::Step {\n",
      "        step_number: 1,\n",
      "        is_moved: 3,\n",
      "    };\n",
      "    let step_case_1_optional = Some(&step_case_1);\n",
      "\n",
      "    let mut step_case_2 = step::Step {\n",
      "        step_number: 2,\n",
      "        is_moved: 4,\n",
      "    };\n",
      "    step_case_2.update_this_step_move_number(step_case_2.is_moved, step_case_1_optional);\n",
      "    let step_case_2_optional = Some(&step_case_2);\n",
      "\n",
      "    let mut step_case_3 = step::Step {\n",
      "        step_number: 3,\n",
      "        is_moved: 5,\n",
      "    };\n",
      "    step_case_3.update_this_step_move_number(step_case_3.is_moved, step_case_2_optional);\n",
      "    let step_case_3_optional = Some(&step_case_3);\n",
      "\n",
      "    let mut step_case_4 = step::Step {\n",
      "        step_number: 4,\n",
      "        is_moved: 2,\n",
      "    };\n",
      "    step_case_4.update_this_step_move_number(step_case_4.is_moved, step_case_3_optional);\n",
      "    let step_case_4_optional = Some(&step_case_4);\n",
      "\n",
      "    let mut step_case_5 = step::Step {\n",
      "        step_number: 5,\n",
      "        is_moved: 0,\n",
      "    };\n",
      "    step_case_5.update_this_step_move_number(step_case_5.is_moved, step_case_4_optional);\n",
      "\n",
      "    let players_name = vec![\"pobi\".to_string(), \"crong\".to_string(), \"honux\".to_string()];\n",
      "\n",
      "    // https://github.com/asomers/mockall/issues/44\n",
      "    let ctx = MockGameFn::new_context();\n",
      "    ctx.expect().returning(|_, _, _| MockGameFn::default());\n",
      "\n",
      "    let mut mock_foo = MockGameFn::new(players_name, 3, 5);\n",
      "    mock_foo.expect_initialize_players()\n",
      "        .returning(|_| MockGameFn::default());\n",
      "    mock_foo.expect_get_number_of_attempts()\n",
      "        .returning(|| 5);\n",
      "    mock_foo.expect_get_number_of_players()\n",
      "        .returning(|| 3);\n",
      "\n",
      "    // let player_names = vec![\"pobi\".to_string(), \"crong\".to_string()];\n",
      "    // let number_of_players = 2;\n",
      "    // let number_of_attempts = 5;\n",
      "    // let game = mock.new(player_names, number_of_players, number_of_attempts);\n",
      "    // assert_eq!(game.number_of_players, 2);\n",
      "    // assert_eq!(game.number_of_attempts, 5);\n",
      "    // assert_eq!(game.players.len(), 2);\n",
      "}\n",
      "\n"
    ],
    "startline": 1,
    "endline": 120
  },
  {
    "path": "rust-racingcar/src/test/test.rs",
    "code": [
      "#[path = \"../model/Step.rs\"] mod step;\n",
      "use std::io;\n",
      "use mockall::automock;\n",
      "use crate::test::step::Step;\n",
      "\n",
      "#[automock]\n",
      "trait Stdin {\n",
      "    fn mock_input_integer(&mut self, buf: &mut String) -> io::Result<usize>;\n",
      "    fn mock_input_names(&mut self, buf: &mut String) -> io::Result<usize>;\n",
      "}\n",
      "\n",
      "fn mock_input_integer(buf: &mut String) -> io::Result<usize> {\n",
      "    buf.push_str(\"3\");\n",
      "    Ok(1)\n",
      "}\n",
      "\n",
      "fn mock_input_names(buf: &mut String) -> io::Result<usize> {\n",
      "    buf.push_str(\"pobi,crong,honux\");\n",
      "    Ok(1)\n",
      "}\n",
      "\n",
      "#[test]\n",
      "fn test_mock_input_integer() {\n",
      "    let mut mock = MockStdin::new();\n",
      "    mock.expect_mock_input_integer()\n",
      "        .times(1)\n",
      "        .returning(mock_input_integer);\n",
      "    let mut buf = String::new();\n",
      "    mock.mock_input_integer(&mut buf).unwrap();\n",
      "    assert_eq!(buf, \"3\");\n",
      "}\n",
      "\n",
      "#[test]\n",
      "fn test_mock_input_names() {\n",
      "    let mut mock = MockStdin::new();\n",
      "    mock.expect_mock_input_names()\n",
      "        .times(1)\n",
      "        .returning(mock_input_names);\n",
      "    let mut buf = String::new();\n",
      "    mock.mock_input_names(&mut buf).unwrap();\n",
      "    assert_eq!(buf, \"pobi,crong,honux\");\n",
      "}\n",
      "\n",
      "#[test]\n",
      "fn test_step_number() {\n",
      "    let last_step: Option<&Step> = None;\n",
      "    let step = Step::new(1, last_step);\n",
      "    assert_eq!(step.get_step_number(), 1);\n",
      "}\n"
    ],
    "startline": 1,
    "endline": 49
  },
  {
    "path": "rust-racingcar/src/model/game.rs",
    "code": [
      "#[path = \"player.rs\"]\n",
      "pub(crate) mod player;\n",
      "use mockall::automock;\n",
      "\n",
      "#[derive(Debug)]\n",
      "pub struct Game {\n",
      "    pub number_of_players: i32,\n",
      "    pub number_of_attempts: i32,\n",
      "    pub(crate) players: Vec<player::Player>\n",
      "}\n",
      "\n",
      "#[automock]\n",
      "pub trait GameFn {\n",
      "    fn new(player_names: Vec<String>, the_number_of_cars: i32, the_number_of_attempts: i32) -> Self;\n",
      "    fn print_the_dash_by_the_amount_of_is_moved_on_steps(&self);\n",
      "    fn print_the_dash_by_the_amount_of_steps_on_this_step(&self, step_number: i32);\n",
      "    fn get_players(&self) -> &Vec<player::Player>;\n",
      "    fn get_number_of_players(&self) -> i32;\n",
      "    fn get_number_of_attempts(&self) -> i32;\n",
      "    fn initialize_players(self, player_names: &Vec<String>) -> Self;\n",
      "    fn play_steps(self) -> Self;\n",
      "}\n",
      "\n",
      "impl GameFn for Game {\n",
      "    fn new(name_of_players: Vec<String>, number_of_players: i32, number_of_attempts: i32) -> Self {\n",
      "        let new_game = Self {\n",
      "            number_of_players,\n",
      "            number_of_attempts,\n",
      "            players: Vec::with_capacity(number_of_players as usize)\n",
      "        };\n",
      "        let new_game = Self::initialize_players(new_game, &name_of_players);\n",
      "        let new_game = Self::play_steps(new_game);\n",
      "        for step_number in 1..=new_game.number_of_attempts {\n",
      "            Self::print_the_dash_by_the_amount_of_steps_on_this_step(&new_game, step_number);\n",
      "        }\n",
      "        new_game\n",
      "    }\n",
      "\n",
      "    // TODO: refactor to output UI\n",
      "    fn print_the_dash_by_the_amount_of_is_moved_on_steps(&self) {\n",
      "        for player in self.players.iter() {\n",
      "            player.print_the_dash_by_the_amount_of_is_moved_on_steps();\n",
      "        }\n",
      "    }\n",
      "\n",
      "    // TODO: refactor to output UI\n",
      "    fn print_the_dash_by_the_amount_of_steps_on_this_step(&self, step_number: i32) {\n",
      "        for player in self.players.iter() {\n",
      "            player.print_the_dash_by_the_amount_of_steps_on_this_step(step_number);\n",
      "        }\n",
      "        println!();\n",
      "    }\n",
      "\n",
      "    fn get_players(&self) -> &Vec<player::Player> {\n",
      "        &self.players\n",
      "    }\n",
      "\n",
      "    fn get_number_of_players(&self) -> i32 {\n",
      "        self.number_of_players\n",
      "    }\n",
      "\n",
      "    fn get_number_of_attempts(&self) -> i32 {\n",
      "        self.number_of_attempts\n",
      "    }\n",
      "\n",
      "    fn initialize_players(mut self, name_of_players: &Vec<String>) -> Self {\n",
      "        for name in name_of_players {\n",
      "            let new_player = player::Player::new(name.to_string(), self.number_of_attempts);\n",
      "            self.players.push(new_player);\n",
      "        }\n",
      "        self\n",
      "    }\n",
      "\n",
      "    fn play_steps(self) -> Self {\n",
      "        let mut this = self;\n",
      "        for player in this.players.iter_mut() {\n",
      "            player.play_steps();\n",
      "        }\n",
      "        this\n",
      "    }\n",
      "}\n"
    ],
    "startline": 1,
    "endline": 81
  },
  {
    "path": "rust-racingcar/src/model/step.rs",
    "code": [
      "use rand::Rng;\n",
      "use std::fmt;\n",
      "\n",
      "#[derive(Debug)]\n",
      "#[derive(Clone)]\n",
      "pub struct Step {\n",
      "    pub is_moved: i32,\n",
      "    pub step_number: i32\n",
      "}\n",
      "\n",
      "impl Step {\n",
      "    pub fn new(step_number: i32, last_step: Option<&Step>) -> Self {\n",
      "        let mut this = Self {\n",
      "            is_moved: 0,\n",
      "            step_number\n",
      "        };\n",
      "        let this_step_move_number: i32 = Self::get_this_step_move_number_by_random();\n",
      "        this = Self::update_this_step_move_number(&mut this, this_step_move_number, last_step);\n",
      "        this\n",
      "    }\n",
      "\n",
      "    pub fn update_this_step_move_number(&mut self, this_step_move_number: i32, last_step: Option<&Step>) -> Step {\n",
      "        if let Some(last_step) = last_step {\n",
      "            return Self {\n",
      "                is_moved: last_step.is_moved + this_step_move_number as i32,\n",
      "                step_number: self.step_number\n",
      "            };\n",
      "        }\n",
      "        return Self {\n",
      "            is_moved: this_step_move_number as i32,\n",
      "            step_number: self.step_number\n",
      "        }\n",
      "    }\n",
      "\n",
      "    pub fn get_this_step_move_number_by_random() -> i32 {\n",
      "        let random_number = rand::thread_rng().gen_range(0, 9);\n",
      "        if random_number > 4 {\n",
      "            return random_number\n",
      "        }\n",
      "        return 0\n",
      "    }\n",
      "\n",
      "    pub fn get_step_number(&self) -> i32 {\n",
      "        self.step_number\n",
      "    }\n",
      "\n",
      "    pub fn get_is_moved(&self) -> i32 {\n",
      "        self.is_moved\n",
      "    }\n",
      "}\n",
      "\n",
      "impl fmt::Display for Step {\n",
      "    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n",
      "        for _ in 0..self.is_moved {\n",
      "            print!(\"-\");\n",
      "        }\n",
      "        Ok(())\n",
      "    }\n",
      "}\n"
    ],
    "startline": 1,
    "endline": 59
  },
  {
    "path": "rust-racingcar/src/model/player.rs",
    "code": [
      "#[path = \"step.rs\"]\n",
      "pub (crate) mod step;\n",
      "\n",
      "#[derive(Debug)]\n",
      "#[derive(Clone)]\n",
      "pub struct Player {\n",
      "    pub(crate) name: String,\n",
      "    pub(crate) steps: Vec<step::Step>\n",
      "}\n",
      "\n",
      "impl Player {\n",
      "    pub fn new(name: String, number_of_attempts: i32) -> Self {\n",
      "        Self {\n",
      "            name,\n",
      "            steps: Vec::with_capacity(number_of_attempts as usize)\n",
      "        }\n",
      "    }\n",
      "\n",
      "    pub fn play_steps(&mut self) {\n",
      "        for step_number in 0..self.steps.capacity() {\n",
      "            // get last step\n",
      "            let last_step = self.steps.last();\n",
      "            let now_step_number = step_number + 1;\n",
      "            let step = step::Step::new(now_step_number as i32, last_step);\n",
      "            self.steps.push(step);\n",
      "        }\n",
      "    }\n",
      "\n",
      "    pub fn get_steps(&self) -> &Vec<step::Step> {\n",
      "        &self.steps\n",
      "    }\n",
      "\n",
      "    pub fn print_the_dash_by_the_amount_of_is_moved_on_steps(&self) {\n",
      "        println!(\"{}\", self.name);\n",
      "        for step in self.steps.iter() {\n",
      "            println!(\"{}\", step);\n",
      "        }\n",
      "    }\n",
      "\n",
      "    pub fn print_the_dash_by_the_amount_of_steps_on_this_step(&self, step_number: i32) {\n",
      "        for step in self.steps.iter() {\n",
      "            if step.get_step_number() == step_number {\n",
      "                println!(\"{}: {}\", self.name, step);\n",
      "                break;\n",
      "            }\n",
      "        }\n",
      "    }\n",
      "\n",
      "    pub fn get_player_name(&self) -> String {\n",
      "        self.name.to_string()\n",
      "    }\n",
      "}\n"
    ],
    "startline": 1,
    "endline": 52
  },
  {
    "path": "rust-racingcar/src/view/input.rs",
    "code": [
      "use std::io;\n",
      "\n",
      "pub fn input_integer() -> i32 {\n",
      "    let mut input_line = String::new();\n",
      "    io::stdin().read_line(&mut input_line).expect(\"\ubb38\uc81c\uac00 \ubc1c\uc0dd\ud588\uc2b5\ub2c8\ub2e4.\");\n",
      "    let x: i32 = input_line.trim().parse().expect(\"\uc22b\uc790\ub97c \uc785\ub825\ud574\uc8fc\uc138\uc694.\");\n",
      "    return x;\n",
      "}\n",
      "\n",
      "pub fn input_names() -> Vec<String> {\n",
      "    let mut input_line = String::new();\n",
      "    io::stdin().read_line(&mut input_line).expect(\"\ubb38\uc81c\uac00 \ubc1c\uc0dd\ud588\uc2b5\ub2c8\ub2e4.\");\n",
      "    let names: String = input_line.trim().parse().expect(\"\uc774\ub984\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694.\");\n",
      "    let names = names.split(\",\").map(|x| x.to_string()).collect();\n",
      "    names\n",
      "}\n"
    ],
    "startline": 1,
    "endline": 16
  }
]